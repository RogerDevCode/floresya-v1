/**
 * Unit Tests: Product Controller
 * Tests HTTP layer for product operations
 * Following MANDATORY_RULES.md and ESLint compliance
 */

import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'

// Define the AppError class first before importing anything that might use it
class AppError extends Error {
  constructor(message, statusCode) {
    super(message)
    this.name = 'AppError'
    this.statusCode = statusCode
  }
}

// Make it available globally for the tests
global.AppError = AppError

// Mock dependencies before importing the controller
vi.mock('../../../../api/services/productService.js', async () => {
  const actual = await vi.importActual('../../../../api/services/productService.js')
  return {
    ...actual,
    getAllProducts: vi.fn(),
    getProductById: vi.fn(),
    getProductBySku: vi.fn(),
    createProduct: vi.fn(),
    updateProduct: vi.fn(),
    updateStock: vi.fn(),
    deleteProduct: vi.fn(),
    reactivateProduct: vi.fn(),
    getProductsWithOccasions: vi.fn(),
    getProductsByOccasion: vi.fn(),
    getCarouselProducts: vi.fn(),
    updateCarouselOrder: vi.fn(),
    createProductWithOccasions: vi.fn(),
    decrementStock: vi.fn(),
    replaceProductOccasions: vi.fn(),
    getProductOccasions: vi.fn(),
    linkProductOccasion: vi.fn()
  }
})

vi.mock('../../../../api/services/carouselService.js', () => ({
  getCarouselProducts: vi.fn(),
  updateCarouselOrder: vi.fn(),
  resolveCarouselOrderConflict: vi.fn()
}))

vi.mock('../../../../api/middleware/errorHandler.js', () => ({
  asyncHandler: (fn) => fn
}))

// We'll import the controller functions directly inside each test to avoid the "read-only" error
let productService
let carouselService

describe('Product Controller', () => {
  let mockReq, mockRes

  beforeEach(async () => {
    // Mock request object
    mockReq = {
      query: {},
      params: {},
      body: {},
      user: { role: 'admin' }
    }

    // Mock response object
    mockRes = {
      status: vi.fn().mockReturnThis(),
      json: vi.fn().mockReturnThis()
    }

    // Clear all mocks
    vi.clearAllMocks()
    
    // Import services after setting up mocks
    productService = await import('../../../../api/services/productService.js')
    carouselService = await import('../../../../api/services/carouselService.js')
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  const mockProduct = {
    id: 1,
    name: 'Test Product',
    price_usd: 29.99,
    stock: 10,
    sku: 'TEST-001',
    active: true
  }

  const mockProducts = [
    mockProduct,
    { id: 2, name: 'Test Product 2', price_usd: 19.99, stock: 5, sku: 'TEST-002', active: true }
  ]

  describe('getAllProducts', () => {
    test('should return products successfully', async () => {
      // Import the function directly inside the test
      const { getAllProducts } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.query = { limit: '10', offset: '0' }
      productService.getAllProducts.mockResolvedValue(mockProducts)

      // Act
      await getAllProducts(mockReq, mockRes)

      // Assert
      expect(productService.getAllProducts).toHaveBeenCalledWith(
        { 
          limit: '10', 
          offset: '0', 
          featured: undefined,
          sku: undefined,
          search: undefined,
          occasion: undefined,
          sortBy: undefined 
        },
        false,  // includeInactive
        null     // includeImageSize
      )
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProducts,
        message: 'Products retrieved successfully'
      })
    })

    test('should handle admin includeInactive parameter', async () => {
      const { getAllProducts } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.query = { includeInactive: 'true' }
      mockReq.user = { role: 'admin' }
      productService.getAllProducts.mockResolvedValue(mockProducts)

      // Act
      await getAllProducts(mockReq, mockRes)

      // Assert
      expect(productService.getAllProducts).toHaveBeenCalledWith(
        expect.objectContaining({ includeInactive: 'true' }),
        true,   // includeInactive
        null    // includeImageSize
      )
    })

    test('should handle non-admin user without includeInactive', async () => {
      const { getAllProducts } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.query = { includeInactive: 'true' }
      mockReq.user = { role: 'user' }
      productService.getAllProducts.mockResolvedValue(mockProducts)

      // Act
      await getAllProducts(mockReq, mockRes)

      // Assert
      expect(productService.getAllProducts).toHaveBeenCalledWith(
        expect.objectContaining({ includeInactive: 'true' }),
        false,  // includeInactive is false for non-admin users
        null    // includeImageSize
      )
    })
  })

  describe('getProductById', () => {
    test('should return product by ID successfully', async () => {
      const { getProductById } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { id: '1' }
      productService.getProductById.mockResolvedValue(mockProduct)

      // Act
      await getProductById(mockReq, mockRes)

      // Assert
      expect(productService.getProductById).toHaveBeenCalledWith(1, false, null)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product retrieved successfully'
      })
    })
  })

  describe('getProductBySku', () => {
    test('should return product by SKU successfully', async () => {
      const { getProductBySku } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { sku: 'TEST-001' }
      productService.getProductBySku.mockResolvedValue(mockProduct)

      // Act
      await getProductBySku(mockReq, mockRes)

      // Assert
      expect(productService.getProductBySku).toHaveBeenCalledWith('TEST-001')
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product retrieved successfully'
      })
    })
  })

  describe('getCarouselProducts', () => {
    test('should return carousel products successfully', async () => {
      const { getCarouselProducts } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      productService.getCarouselProducts.mockResolvedValue(mockProducts)

      // Act
      await getCarouselProducts(mockReq, mockRes)

      // Assert
      expect(productService.getCarouselProducts).toHaveBeenCalled()
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProducts,
        message: 'Carousel products retrieved successfully'
      })
    })
  })

  describe('createProduct', () => {
    test('should create product successfully', async () => {
      const { createProduct } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const newProductData = {
        name: 'New Product',
        price_usd: 39.99,
        stock: 15,
        sku: 'NEW-001'
      }
      mockReq.body = newProductData
      productService.createProduct.mockResolvedValue(mockProduct)

      // Act
      await createProduct(mockReq, mockRes)

      // Assert
      expect(productService.createProduct).toHaveBeenCalledWith(newProductData)
      expect(mockRes.status).toHaveBeenCalledWith(201)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product created successfully'
      })
    })

    test('should handle validation errors', async () => {
      const { createProduct } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const invalidData = { name: '' } // Invalid product data
      mockReq.body = invalidData
      const error = new Error('Validation failed')
      productService.createProduct.mockRejectedValue(error)

      // Act & Assert
      await expect(createProduct(mockReq, mockRes)).rejects.toThrow('Validation failed')
    })
  })

  describe('updateProduct', () => {
    test('should update product successfully', async () => {
      const { updateProduct } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const updateData = {
        name: 'Updated Product',
        price_usd: 49.99
      }
      mockReq.params = { id: '1' }
      mockReq.body = updateData
      productService.updateProduct.mockResolvedValue(mockProduct)

      // Act
      await updateProduct(mockReq, mockRes)

      // Assert
      expect(productService.updateProduct).toHaveBeenCalledWith(1, updateData)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product updated successfully'
      })
    })
  })

  describe('updateStock', () => {
    test('should update product stock successfully', async () => {
      const { updateStock } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const stockData = { stock: 25 }
      mockReq.params = { id: '1' }
      mockReq.body = stockData
      productService.updateStock.mockResolvedValue(mockProduct)

      // Act
      await updateStock(mockReq, mockRes)

      // Assert
      expect(productService.updateStock).toHaveBeenCalledWith(1, 25)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Stock updated successfully'
      })
    })
  })

  describe('deleteProduct', () => {
    test('should delete product successfully', async () => {
      const { deleteProduct } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { id: '1' }
      productService.deleteProduct.mockResolvedValue(mockProduct)

      // Act
      await deleteProduct(mockReq, mockRes)

      // Assert
      expect(productService.deleteProduct).toHaveBeenCalledWith(1)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product deactivated successfully'
      })
    })
  })

  describe('reactivateProduct', () => {
    test('should reactivate product successfully', async () => {
      const { reactivateProduct } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { id: '1' }
      productService.reactivateProduct.mockResolvedValue(mockProduct)

      // Act
      await reactivateProduct(mockReq, mockRes)

      // Assert
      expect(productService.reactivateProduct).toHaveBeenCalledWith(1)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product reactivated successfully'
      })
    })
  })

  describe('updateCarouselOrder', () => {
    test('should update carousel order successfully', async () => {
      const { updateCarouselOrder } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { id: '1' }
      mockReq.body = { order: 2 }
      productService.updateCarouselOrder.mockResolvedValue(mockProduct)

      // Act
      await updateCarouselOrder(mockReq, mockRes)

      // Assert
      expect(productService.updateCarouselOrder).toHaveBeenCalledWith(1, 2)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Carousel order updated successfully'
      })
    })
  })

  describe('createProductWithOccasions', () => {
    test('should create product with occasions successfully', async () => {
      const { createProductWithOccasions } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const productData = {
        product: {
          name: 'Product with Occasions',
          price_usd: 29.99,
          stock: 10,
          sku: 'OCC-001'
        },
        occasionIds: [1, 2, 3]
      }
      mockReq.body = productData
      productService.createProductWithOccasions.mockResolvedValue(mockProduct)

      // Act
      await createProductWithOccasions(mockReq, mockRes)

      // Assert
      expect(productService.createProductWithOccasions).toHaveBeenCalledWith(
        { name: 'Product with Occasions', price_usd: 29.99, stock: 10, sku: 'OCC-001' },
        [1, 2, 3]
      )
      expect(mockRes.status).toHaveBeenCalledWith(201)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProduct,
        message: 'Product with occasions created successfully'
      })
    })
  })

  describe('getProductsWithOccasions', () => {
    test('should return products with occasions successfully', async () => {
      const { getProductsWithOccasions } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.query = { limit: '10', offset: '0' }
      const productsWithOccasions = mockProducts.map(product => ({
        ...product,
        product_occasions: [{ occasion_id: 1, occasions: { id: 1, name: 'Birthday', slug: 'birthday' } }]
      }))
      productService.getProductsWithOccasions.mockResolvedValue(productsWithOccasions)

      // Act
      await getProductsWithOccasions(mockReq, mockRes)

      // The controller sends string values from query params, but the service expects numbers
      expect(productService.getProductsWithOccasions).toHaveBeenCalledWith(10, 0)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: productsWithOccasions,
        message: 'Products with occasions retrieved successfully'
      })
    })
  })

  describe('getProductsByOccasion', () => {
    test('should return products by occasion successfully', async () => {
      const { getProductsByOccasion } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { occasionId: '1' }
      mockReq.query = { limit: '10' }
      productService.getProductsByOccasion.mockResolvedValue(mockProducts)

      // Act
      await getProductsByOccasion(mockReq, mockRes)

      // Controller converts string to number when calling service
      expect(productService.getProductsByOccasion).toHaveBeenCalledWith(1, 10)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: mockProducts,
        message: 'Products retrieved successfully'
      })
    })
  })

  describe('getProductOccasions', () => {
    test('should return product occasions successfully', async () => {
      const { getProductOccasions } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { id: '1' }
      const occasions = [{ id: 1, name: 'Birthday' }, { id: 2, name: 'Anniversary' }]
      productService.getProductOccasions.mockResolvedValue(occasions)

      // Act
      await getProductOccasions(mockReq, mockRes)

      // Assert
      expect(productService.getProductOccasions).toHaveBeenCalledWith(1)
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: occasions,
        message: 'Product occasions retrieved successfully'
      })
    })
  })

  describe('linkProductOccasion', () => {
    test('should link product to occasion successfully', async () => {
      const { linkProductOccasion } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.params = { id: '1', occasionId: '2' }
      productService.linkProductOccasion.mockResolvedValue(true)

      // Act
      await linkProductOccasion(mockReq, mockRes)

      // Assert
      expect(productService.linkProductOccasion).toHaveBeenCalledWith(1, '2')
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: true,
        message: 'Occasion linked to product successfully'
      })
    })
  })

  describe('replaceProductOccasions', () => {
    test('should replace product occasions successfully', async () => {
      const { replaceProductOccasions } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const occasionsData = { occasion_ids: [1, 2, 3] }
      mockReq.params = { id: '1' }
      mockReq.body = occasionsData
      productService.replaceProductOccasions.mockResolvedValue(true)

      // Act
      await replaceProductOccasions(mockReq, mockRes)

      // Assert
      expect(productService.replaceProductOccasions).toHaveBeenCalledWith(1, [1, 2, 3])
      expect(mockRes.status).toHaveBeenCalledWith(200)
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: true,
        message: 'Product occasions updated successfully'
      })
    })
  })

  describe('Error Handling', () => {
    test('should handle service errors gracefully', async () => {
      const { getAllProducts } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      const error = new Error('Service error')
      productService.getAllProducts.mockRejectedValue(error)

      // Act & Assert
      await expect(getAllProducts(mockReq, mockRes)).rejects.toThrow('Service error')
      expect(mockRes.status).not.toHaveBeenCalled()
      expect(mockRes.json).not.toHaveBeenCalled()
    })
  })

  describe('Input Validation', () => {
    test('should handle missing request body', async () => {
      const { createProduct } = await import('../../../../api/controllers/productController.js')
      
      // Arrange
      mockReq.body = null
      const error = new Error('Request body is required')
      productService.createProduct.mockRejectedValue(error)

      // Act & Assert
      await expect(createProduct(mockReq, mockRes)).rejects.toThrow('Request body is required')
    })
  })
})