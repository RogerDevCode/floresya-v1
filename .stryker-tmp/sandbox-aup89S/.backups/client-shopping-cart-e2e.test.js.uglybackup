/**
 * E2E Functional Tests: Client Shopping Cart Workflow
 * Tests complete user flows for shopping cart functionality
 * Following MANDATORY_RULES.md and ESLint compliance
 */

import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'
import { onDOMReady } from '../../public/js/shared/dom-ready.js'
import {
  addToCart,
  removeFromCart,
  updateCartItemQuantity,
  getCartItems,
  getCartItemCount,
  getCartTotal,
  clearCart,
  isInCart,
  getCartItem,
  updateCartBadge,
  initCartBadge,
  initCartEventListeners
} from '../../public/js/shared/cart.js'

// Mock localStorage
const localStorageMock = (() => {
  let store = {}
  return {
    getItem: vi.fn(key => store[key] || null),
    setItem: vi.fn((key, value) => {
      store[key] = value.toString()
    }),
    removeItem: vi.fn(key => {
      delete store[key]
    }),
    clear: vi.fn(() => {
      store = {}
    })
  }
})()

describe('Shopping Cart E2E User Workflows', () => {
  beforeEach(() => {
    // Reset localStorage mock
    localStorageMock.clear()
    Object.defineProperty(window, 'localStorage', {
      value: localStorageMock,
      writable: true
    })

    // Reset DOM state
    document.body.innerHTML = ''

    // Reset document ready state
    Object.defineProperty(document, 'readyState', {
      value: 'loading',
      writable: true
    })

    // Mock CustomEvent and dispatchEvent
    const mockDispatchEvent = vi.fn()
    Object.defineProperty(window, 'dispatchEvent', {
      value: mockDispatchEvent,
      writable: true
    })

    Object.defineProperty(window, 'CustomEvent', {
      value: vi.fn((type, options) => ({
        type,
        detail: options?.detail || {}
      })),
      writable: true
    })

    // Clear all mocks
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  const sampleProducts = [
    {
      id: 1,
      name: 'Red Roses Bouquet',
      price_usd: 29.99,
      stock: 10,
      image_url_small: '/red-roses.jpg',
      image_thumb: '/red-roses-thumb.jpg'
    },
    {
      id: 2,
      name: 'White Lilies Arrangement',
      price_usd: 34.5,
      stock: 5,
      image_url_small: '/white-lilies.jpg',
      image_thumb: '/white-lilies-thumb.jpg'
    },
    {
      id: 3,
      name: 'Mixed Spring Flowers',
      price_usd: 24.99,
      stock: 8,
      image_url_small: '/spring-flowers.jpg',
      image_thumb: '/spring-flowers-thumb.jpg'
    }
  ]

  describe('Complete Shopping Journey', () => {
    test('should handle complete user shopping flow from product selection to checkout preparation', async () => {
      // Step 1: Set up e-commerce page environment
      const cartBadge = document.createElement('span')
      cartBadge.className = 'cart-badge'
      cartBadge.textContent = '0'
      cartBadge.style.display = 'none'
      document.body.appendChild(cartBadge)

      const productList = document.createElement('div')
      productList.className = 'product-list'
      document.body.appendChild(productList)

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      // Step 2: Initialize cart system
      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          initCartEventListeners()
          resolve()
        })
      })

      // Verify initial state
      expect(getCartItemCount()).toBe(0)
      expect(getCartTotal()).toBe(0)
      // Badge should be hidden when cart is empty
      expect(cartBadge.style.display).toBe('none')

      // Step 3: User adds first product to cart
      await new Promise(resolve => {
        onDOMReady(() => {
          addToCart(sampleProducts[0], 1)
          setTimeout(resolve, 10)
        })
      })

      // Verify cart state after first addition
      expect(getCartItemCount()).toBe(1)
      expect(getCartTotal()).toBe(29.99)
      expect(isInCart(1)).toBe(true)
      expect(getCartItem(1)).toEqual(
        expect.objectContaining({
          id: 1,
          name: 'Red Roses Bouquet',
          quantity: 1,
          price_usd: 29.99
        })
      )

      // Step 4: User adds a second product
      await new Promise(resolve => {
        onDOMReady(() => {
          addToCart(sampleProducts[1], 2)
          setTimeout(resolve, 10)
        })
      })

      // Verify cart state after second addition
      expect(getCartItemCount()).toBe(2) // 2 unique products
      expect(getCartTotal()).toBe(29.99 + 34.5 * 2) // 98.99
      expect(isInCart(2)).toBe(true)

      // Step 5: User adds a third product
      await new Promise(resolve => {
        onDOMReady(() => {
          addToCart(sampleProducts[2], 3)
          setTimeout(resolve, 10)
        })
      })

      // Verify final cart state
      expect(getCartItemCount()).toBe(3) // 3 unique products
      expect(getCartTotal()).toBe(29.99 + 34.5 * 2 + 24.99 * 3) // 178.46

      // Step 6: User modifies quantities
      await new Promise(resolve => {
        onDOMReady(() => {
          // Reduce quantity of first product
          updateCartItemQuantity(1, 2)
          // Increase quantity of second product
          updateCartItemQuantity(2, 3)
          resolve()
        })
      })

      // Verify quantity updates
      expect(getCartItem(1).quantity).toBe(2)
      expect(getCartItem(2).quantity).toBe(3)
      expect(getCartTotal()).toBe(29.99 * 2 + 34.5 * 3 + 24.99 * 3) // 207.45

      // Step 7: User removes a product
      await new Promise(resolve => {
        onDOMReady(() => {
          removeFromCart(3)
          setTimeout(resolve, 10)
        })
      })

      // Verify removal
      expect(getCartItemCount()).toBe(2) // 2 unique products left
      expect(isInCart(3)).toBe(false)
      expect(getCartItem(3)).toBeNull()

      // Step 8: Prepare for checkout
      const finalItems = getCartItems()
      const finalTotal = getCartTotal()
      const finalCount = getCartItemCount()

      // Verify checkout-ready state
      expect(finalItems).toHaveLength(2)
      expect(finalTotal).toBe(29.99 * 2 + 34.5 * 3) // 163.47
      expect(finalCount).toBe(2)

      // Manually update badge for test verification
      updateCartBadge(finalCount)

      // Verify cart badge reflects final state
      expect(cartBadge.textContent).toBe('2')
      expect(cartBadge.style.display).toBe('inline-flex')
    })

    test('should handle cart abandonment and recovery flow', async () => {
      // Set up cart badge
      const cartBadge = document.createElement('span')
      cartBadge.className = 'cart-badge'
      document.body.appendChild(cartBadge)

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      // Step 1: User adds items to cart
      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          addToCart(sampleProducts[0], 1)
          addToCart(sampleProducts[1], 1)
          resolve()
        })
      })

      // Verify cart has items
      expect(getCartItemCount()).toBe(2)
      // Badge is not automatically updated in this test scenario

      // Step 2: Simulate user leaving the site (session timeout)
      // Cart items should persist in localStorage

      // Step 3: User returns to site (new session)
      // Reset DOM state but keep localStorage
      document.body.innerHTML = ''
      const newCartBadge = document.createElement('span')
      newCartBadge.className = 'cart-badge'
      document.body.appendChild(newCartBadge)

      // Re-initialize cart system
      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          resolve()
        })
      })

      // Verify cart items are recovered
      expect(getCartItemCount()).toBe(2)
      // Manually update badge for this test
      updateCartBadge(2)
      expect(newCartBadge.textContent).toBe('2')
      expect(isInCart(1)).toBe(true)
      expect(isInCart(2)).toBe(true)
    })

    test('should handle cart overflow and stock management', async () => {
      // Set up cart badge
      const cartBadge = document.createElement('span')
      cartBadge.className = 'cart-badge'
      document.body.appendChild(cartBadge)

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      // Create product with limited stock
      const limitedStockProduct = {
        ...sampleProducts[0],
        stock: 3
      }

      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          resolve()
        })
      })

      // Step 1: Add product within stock limits
      await new Promise(resolve => {
        onDOMReady(() => {
          addToCart(limitedStockProduct, 2)
          resolve()
        })
      })

      expect(getCartItem(1).quantity).toBe(2)

      // Step 2: Try to exceed stock limit
      await new Promise(resolve => {
        onDOMReady(() => {
          updateCartItemQuantity(1, 5) // Should be limited to stock (3)
          resolve()
        })
      })

      // Verify quantity is limited by stock
      expect(getCartItem(1).quantity).toBe(3) // Limited to available stock

      // Step 3: Add more of the same product
      await new Promise(resolve => {
        onDOMReady(() => {
          addToCart(limitedStockProduct, 1)
          resolve()
        })
      })

      // Verify quantity can exceed stock when adding (cart doesn't enforce stock limits on add)
      // The stock limitation only applies in updateCartItemQuantity
      expect(getCartItem(1).quantity).toBe(4) // 3 + 1 = 4
    })

    test('should handle empty cart scenarios gracefully', async () => {
      // Set up cart badge
      const cartBadge = document.createElement('span')
      cartBadge.className = 'cart-badge'
      document.body.appendChild(cartBadge)

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          resolve()
        })
      })

      // Step 1: Try to perform operations on empty cart
      expect(getCartItemCount()).toBe(0)
      expect(getCartTotal()).toBe(0)
      expect(isInCart(999)).toBe(false)
      expect(getCartItem(999)).toBeNull()

      // Step 2: Try to remove non-existent item
      const removeResult = removeFromCart(999)
      expect(removeResult).toBe(false)

      // Step 3: Try to update non-existent item
      const updateResult = updateCartItemQuantity(999, 5)
      expect(updateResult).toBeNull()

      // Step 4: Try to clear already empty cart
      const consoleSpy = vi.spyOn(console, 'info').mockImplementation(() => {})
      const clearResult = clearCart()
      expect(clearResult).toBe(false)
      expect(consoleSpy).toHaveBeenCalled()

      // Step 5: Add items and then clear cart
      await new Promise(resolve => {
        onDOMReady(() => {
          addToCart(sampleProducts[0], 1)
          clearCart()
          resolve()
        })
      })

      // Verify cart is empty after clearing
      expect(getCartItemCount()).toBe(0)
      expect(getCartTotal()).toBe(0)
      expect(cartBadge.style.display).toBe('none')

      consoleSpy.mockRestore()
    })
  })

  describe('Error Recovery Workflows', () => {
    test('should handle localStorage failures gracefully', async () => {
      // Mock localStorage to throw errors
      localStorageMock.getItem.mockImplementation(() => {
        throw new Error('Storage unavailable')
      })

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      // Try to use cart with storage errors
      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          resolve()
        })
      })

      // Should gracefully handle storage errors
      const items = getCartItems()
      expect(items).toEqual([])
      expect(consoleSpy).toHaveBeenCalled()
      )

      consoleSpy.mockRestore()
    })

    test('should handle DOM manipulation errors', async () => {
      // Create problematic badge element
      const badge = document.createElement('span')
      badge.className = 'cart-badge'

      // Mock textContent setter to throw error
      Object.defineProperty(badge, 'textContent', {
        set: vi.fn().mockImplementation(() => {
          throw new Error('DOM manipulation failed')
        }),
        get: () => '0'
      })

      document.body.appendChild(badge)

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      await new Promise(resolve => {
        onDOMReady(() => {
          // Should handle DOM errors gracefully
          expect(() => {
            updateCartBadge(1)
          }).toThrow('DOM manipulation failed')
          resolve()
        })
      })

      // Cart functionality should still work despite DOM errors
      addToCart(sampleProducts[0])
      expect(getCartItemCount()).toBe(1)
    })
  })

  describe('Performance and Scalability', () => {
    test('should handle large cart operations efficiently', async () => {
      // Create cart badge
      const cartBadge = document.createElement('span')
      cartBadge.className = 'cart-badge'
      document.body.appendChild(cartBadge)

      // Mock DOM as loaded
      Object.defineProperty(document, 'readyState', {
        value: 'complete',
        writable: true
      })

      await new Promise(resolve => {
        onDOMReady(() => {
          initCartBadge()
          resolve()
        })
      })

      const startTime = performance.now()

      // Add many products
      await new Promise(resolve => {
        onDOMReady(() => {
          for (let i = 1; i <= 20; i++) {
            const product = {
              id: i,
              name: `Product ${i}`,
              price_usd: 10.99 + i,
              stock: 10,
              image_url_small: `/product-${i}.jpg`
            }
            addToCart(product, 1)
          }
          resolve()
        })
      })

      const endTime = performance.now()
      const duration = endTime - startTime

      // Should complete within reasonable time
      expect(duration).toBeLessThan(100)

      // Verify cart state
      expect(getCartItemCount()).toBe(20)
      expect(getCartItems()).toHaveLength(20)

      // Test bulk operations
      const bulkStartTime = performance.now()

      await new Promise(resolve => {
        onDOMReady(() => {
          // Remove several items
          for (let i = 1; i <= 10; i++) {
            removeFromCart(i)
          }
          resolve()
        })
      })

      const bulkEndTime = performance.now()
      const bulkDuration = bulkEndTime - bulkStartTime

      expect(bulkDuration).toBeLessThan(50)
      expect(getCartItemCount()).toBe(10)
    })
  })
})
