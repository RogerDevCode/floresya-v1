/**
 * Comprehensive Malware Scanning Service
 * Enterprise-grade malware detection and file quarantine system
 *
 * Features:
 * - File type validation and content verification
 * - Magic number detection
 * - Embedded script detection
 * - Metadata scanning
 * - File size limits
 * - Quarantine system
 * - Virus scanning integration (ClamAV)
 * - Heuristic analysis
 * - File hash verification
 * - Suspicious pattern detection
 */

import { createHash } from 'crypto'
import { readFileSync, unlinkSync, mkdirSync, existsSync, writeFileSync } from 'fs'
import { join } from 'path'
import { SecurityError } from '../../errors/AppError.js'
import { logger } from '../../utils/logger.js'
import config from '../../config/configLoader.js'

/**
 * Allowed file types and their magic numbers
 */
const ALLOWED_FILE_TYPES = {
  'image/jpeg': {
    extensions: ['.jpg', '.jpeg'],
    magicNumbers: [/^\xFF\xD8\xFF/],
    maxFileSize: 5 * 1024 * 1024, // 5MB
    description: 'JPEG Image'
  },
  'image/png': {
    extensions: ['.png'],
    // eslint-disable-next-line no-control-regex
    magicNumbers: [/^\x89\x50\x4E\x47\x0D\x0A\x1A\x0A/],
    maxFileSize: 5 * 1024 * 1024, // 5MB
    description: 'PNG Image'
  },
  'image/webp': {
    extensions: ['.webp'],
    magicNumbers: [/^RIFF....WEBP/],
    maxFileSize: 5 * 1024 * 1024, // 5MB
    description: 'WebP Image'
  },
  'image/gif': {
    extensions: ['.gif'],
    magicNumbers: [/^GIF87a/, /^GIF89a/],
    maxFileSize: 5 * 1024 * 1024, // 5MB
    description: 'GIF Image'
  }
}

/**
 * Dangerous file extensions to block
 */
const DANGEROUS_EXTENSIONS = [
  '.exe',
  '.bat',
  '.cmd',
  '.com',
  '.pif',
  '.scr',
  '.vbs',
  '.js',
  '.jar',
  '.app',
  '.deb',
  '.pkg',
  '.dmg',
  '.rpm',
  '.deb',
  '.msi',
  '.msp',
  '.msm',
  '.msp',
  '.bat',
  '.cmd',
  '.com',
  '.cpl',
  '.csh',
  '.inf',
  '.ins',
  '.isp',
  '.jse',
  '.js',
  '.jse',
  '.lnk',
  '.msc',
  '.msi',
  '.msp',
  '.mst',
  '.ps1',
  '.ps1xml',
  '.ps2',
  '.ps2xml',
  '.psc1',
  '.psc2',
  '.psd1',
  '.psdm1',
  '.scf',
  '.shs',
  '.tmp',
  '.url',
  '.vb',
  '.vbe',
  '.vbs',
  '.vbscript',
  '.ws',
  '.wsf',
  '.wsh',
  '.php',
  '.php3',
  '.php4',
  '.php5',
  '.phtml',
  '.pl',
  '.py',
  '.rb',
  '.cgi',
  '.sh',
  '.bash',
  '.zsh',
  '.fish',
  '.ps1',
  '.bat',
  '.cmd'
]

/**
 * Suspicious patterns in file content
 */
const SUSPICIOUS_PATTERNS = [
  // Script tags
  /<script[\s\S]*?<\/script>/gi,
  /<%[\s\S]*?%>/g,
  /<\?php[\s\S]*?\?>/gi,

  // JavaScript code
  /javascript:/gi,
  /vbscript:/gi,
  /on\w+\s*=/gi,
  /eval\s*\(/gi,
  /exec\s*\(/gi,
  /system\s*\(/gi,
  /shell_exec\s*\(/gi,
  /passthru\s*\(/gi,

  // PHP code
  /<\?php/gi,
  /<\?=/gi,

  // Shell commands
  /\$\(/g,
  /`[^`]*`/g,
  /\$\{[^}]*\}/g,

  // Base64 encoded content (potential hidden scripts)
  /base64_decode\s*\(/gi,
  /eval\s*\(\s*base64_decode/gi,

  // File inclusion attempts
  /include\s*\(/gi,
  /require\s*\(/gi,
  /file_get_contents\s*\(/gi,
  /fopen\s*\(/gi,

  // Database operations
  /mysql_query\s*\(/gi,
  /mysqli_query\s*\(/gi,
  /pg_query\s*\(/gi,

  // System calls
  /system\s*\(/gi,
  /exec\s*\(/gi,
  /passthru\s*\(/gi,
  /shell_exec\s*\(/gi
]

/**
 * Quarantine directory configuration
 */
const QUARANTINE_DIR = process.env.QUARANTINE_DIR || './quarantine'

/**
 * Malware Scanning Service
 */
export class MalwareScanningService {
  /**
   * Scan uploaded file for malware and security threats
   * @param {Object} file - File object from multer
   * @param {Object} options - Scanning options
   * @returns {Object} Scan result
   * @throws {SecurityError} If malware is detected
   */
  static async scanFile(file, options = {}) {
    const {
      strictMode = true,
      enableClamAV = process.env.ENABLE_CLAMAV === 'true',
      quarantineSuspicious = true,
      maxFileSize = config.upload.maxSize
    } = options

    logger.info('Starting malware scan', {
      filename: file.originalname,
      mimetype: file.mimetype,
      size: file.size
    })

    const scanResult = {
      filename: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      scannedAt: new Date().toISOString(),
      threats: [],
      isClean: true,
      quarantined: false
    }

    try {
      // Read file content
      const fileContent = readFileSync(file.path)

      // 1. File size validation
      this.validateFileSize(file.size, maxFileSize, scanResult)

      // 2. File extension validation
      this.validateFileExtension(file.originalname, scanResult)

      // 3. MIME type validation
      this.validateMimeType(file.mimetype, scanResult)

      // 4. Magic number validation
      this.validateMagicNumbers(fileContent, file.mimetype, scanResult)

      // 5. Content scanning for suspicious patterns
      this.scanForSuspiciousPatterns(fileContent, scanResult)

      // 6. Metadata scanning
      this.scanMetadata(file, scanResult)

      // 7. File hash calculation
      const fileHash = this.calculateFileHash(fileContent)
      scanResult.fileHash = fileHash

      // 8. Check against known malicious hashes (if database available)
      await this.checkMaliciousHashes(fileHash, scanResult)

      // 9. ClamAV scanning (if enabled)
      if (enableClamAV) {
        await this.scanWithClamAV(file.path, scanResult)
      }

      // 10. Heuristic analysis
      this.performHeuristicAnalysis(fileContent, scanResult)

      // Determine if file is clean
      scanResult.isClean = scanResult.threats.length === 0

      // Quarantine if suspicious and quarantine is enabled
      if (!scanResult.isClean && quarantineSuspicious) {
        await this.quarantineFile(file, scanResult)
        scanResult.quarantined = true
      }

      // Log scan results
      if (scanResult.isClean) {
        logger.info('File scan completed - clean', {
          filename: file.originalname,
          hash: fileHash,
          size: file.size
        })
      } else {
        logger.warn('File scan completed - threats detected', {
          filename: file.originalname,
          hash: fileHash,
          threats: scanResult.threats,
          quarantined: scanResult.quarantined
        })
      }

      // Throw error in strict mode if threats detected
      if (strictMode && !scanResult.isClean) {
        throw new SecurityError('File contains malicious content and has been blocked', {
          filename: file.originalname,
          threats: scanResult.threats,
          quarantined: scanResult.quarantined
        })
      }

      return scanResult
    } catch (error) {
      logger.error('File scan failed', {
        filename: file.originalname,
        error: error.message,
        stack: error.stack
      })

      // Clean up temporary file
      try {
        unlinkSync(file.path)
      } catch (cleanupError) {
        logger.warn('Failed to clean up temporary file', {
          filename: file.originalname,
          error: cleanupError.message
        })
      }

      throw error
    }
  }

  /**
   * Validate file size
   * @param {number} size - File size
   * @param {number} maxSize - Maximum allowed size
   * @param {Object} scanResult - Scan result object
   */
  static validateFileSize(size, maxSize, scanResult) {
    if (size > maxSize) {
      const threat = {
        type: 'FILE_SIZE_EXCEEDED',
        severity: 'medium',
        description: `File size ${size} exceeds maximum allowed size ${maxSize}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Validate file extension
   * @param {string} filename - Original filename
   * @param {Object} scanResult - Scan result object
   */
  static validateFileExtension(filename, scanResult) {
    const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'))

    // Check for dangerous extensions
    if (DANGEROUS_EXTENSIONS.includes(extension)) {
      const threat = {
        type: 'DANGEROUS_EXTENSION',
        severity: 'high',
        description: `Dangerous file extension detected: ${extension}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
      return
    }

    // Check if extension matches allowed types
    const allowedExtensions = Object.values(ALLOWED_FILE_TYPES).flatMap(type => type.extensions)

    if (!allowedExtensions.includes(extension)) {
      const threat = {
        type: 'UNSUPPORTED_EXTENSION',
        severity: 'medium',
        description: `Unsupported file extension: ${extension}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Validate MIME type
   * @param {string} mimetype - MIME type
   * @param {Object} scanResult - Scan result object
   */
  static validateMimeType(mimetype, scanResult) {
    if (!ALLOWED_FILE_TYPES[mimetype]) {
      const threat = {
        type: 'UNSUPPORTED_MIME_TYPE',
        severity: 'medium',
        description: `Unsupported MIME type: ${mimetype}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Validate magic numbers
   * @param {Buffer} fileContent - File content
   * @param {string} mimetype - Expected MIME type
   * @param {Object} scanResult - Scan result object
   */
  static validateMagicNumbers(fileContent, mimetype, scanResult) {
    const fileType = ALLOWED_FILE_TYPES[mimetype]

    if (!fileType) {
      return
    }

    const isValidMagicNumber = fileType.magicNumbers.some(pattern =>
      pattern.test(fileContent.toString('binary'))
    )

    if (!isValidMagicNumber) {
      const threat = {
        type: 'MAGIC_NUMBER_MISMATCH',
        severity: 'high',
        description: `File magic numbers don't match MIME type ${mimetype}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Scan for suspicious patterns in file content
   * @param {Buffer} fileContent - File content
   * @param {Object} scanResult - Scan result object
   */
  static scanForSuspiciousPatterns(fileContent, scanResult) {
    const content = fileContent.toString('utf8', 0, Math.min(fileContent.length, 1024 * 1024)) // First 1MB

    for (const pattern of SUSPICIOUS_PATTERNS) {
      const matches = content.match(pattern)
      if (matches) {
        const threat = {
          type: 'SUSPICIOUS_PATTERN',
          severity: 'high',
          description: `Suspicious pattern detected: ${pattern.toString()}`,
          pattern: pattern.toString(),
          matches: matches.length,
          detectedAt: new Date().toISOString()
        }
        scanResult.threats.push(threat)
      }
    }
  }

  /**
   * Scan file metadata
   * @param {Object} file - File object
   * @param {Object} scanResult - Scan result object
   */
  static scanMetadata(file, scanResult) {
    // Check for double extensions
    const nameParts = file.originalname.split('.')
    if (nameParts.length > 2) {
      const threat = {
        type: 'DOUBLE_EXTENSION',
        severity: 'medium',
        description: `File with double extension detected: ${file.originalname}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }

    // Check for suspicious filenames
    const suspiciousNames = [
      'shell',
      'backdoor',
      'webshell',
      'cmd',
      'eval',
      'exec',
      'system',
      'passthru',
      'phpinfo',
      'test',
      'debug'
    ]

    const lowerFilename = file.originalname.toLowerCase()
    if (suspiciousNames.some(name => lowerFilename.includes(name))) {
      const threat = {
        type: 'SUSPICIOUS_FILENAME',
        severity: 'medium',
        description: `Suspicious filename detected: ${file.originalname}`,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Calculate file hash
   * @param {Buffer} fileContent - File content
   * @returns {string} SHA-256 hash
   */
  static calculateFileHash(fileContent) {
    return createHash('sha256').update(fileContent).digest('hex')
  }

  /**
   * Check against known malicious hashes
   * @param {string} fileHash - File hash
   * @param {Object} scanResult - Scan result object
   */
  static async checkMaliciousHashes(fileHash, scanResult) {
    // In a real implementation, this would check against a malware database
    // For now, we'll implement a basic local check

    const knownMaliciousHashes = process.env.KNOWN_MALICIOUS_HASHES?.split(',') || []

    if (knownMaliciousHashes.includes(fileHash)) {
      const threat = {
        type: 'KNOWN_MALWARE',
        severity: 'critical',
        description: `File hash matches known malware: ${fileHash}`,
        hash: fileHash,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Scan with ClamAV (if available)
   * @param {string} filePath - Path to file
   * @param {Object} scanResult - Scan result object
   */
  static async scanWithClamAV(filePath, scanResult) {
    try {
      // This would require the 'clamav.js' package or similar
      // For now, we'll simulate the scan

      logger.debug('Scanning with ClamAV', { filePath })

      // Simulate ClamAV scan
      // In production, this would be:
      // const clamav = require('clamav.js')
      // const result = await clamav.scanFile(filePath)

      // Placeholder implementation
      const isClean = true // Would be result from ClamAV

      if (!isClean) {
        const threat = {
          type: 'CLAMAV_DETECTION',
          severity: 'critical',
          description: 'ClamAV detected malware',
          detectedAt: new Date().toISOString()
        }
        scanResult.threats.push(threat)
      }
    } catch (error) {
      logger.warn('ClamAV scan failed', {
        filePath,
        error: error.message
      })
      // Don't fail the entire scan if ClamAV is unavailable
    }
  }

  /**
   * Perform heuristic analysis
   * @param {Buffer} fileContent - File content
   * @param {Object} scanResult - Scan result object
   */
  static performHeuristicAnalysis(fileContent, scanResult) {
    // Check for high entropy (potential encrypted malware)
    const entropy = this.calculateEntropy(fileContent)
    if (entropy > 7.5) {
      const threat = {
        type: 'HIGH_ENTROPY',
        severity: 'medium',
        description: `High entropy detected: ${entropy.toFixed(2)} (possible encrypted content)`,
        entropy: entropy,
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }

    // Check for executable patterns
    const executablePatterns = [
      /^\x4D\x5A/, // Windows PE
      /^\x7FELF/, // Linux ELF
      /^\xCA\xFE\xBA\xBE/, // Java class
      /^\xFE\xED\xFA/, // Mach-O binary
      /^\xFC\xCF\xAB/ // Compressed executable
    ]

    const isExecutable = executablePatterns.some(pattern => pattern.test(fileContent))
    if (isExecutable) {
      const threat = {
        type: 'EXECUTABLE_CONTENT',
        severity: 'critical',
        description: 'Executable content detected in non-executable file',
        detectedAt: new Date().toISOString()
      }
      scanResult.threats.push(threat)
    }
  }

  /**
   * Calculate Shannon entropy of data
   * @param {Buffer} data - Data to analyze
   * @returns {number} Entropy value
   */
  static calculateEntropy(data) {
    const frequency = new Array(256).fill(0)

    // Count frequency of each byte
    for (let i = 0; i < data.length; i++) {
      frequency[data[i]]++
    }

    // Calculate entropy
    let entropy = 0
    for (let i = 0; i < 256; i++) {
      if (frequency[i] > 0) {
        const probability = frequency[i] / data.length
        entropy -= probability * Math.log2(probability)
      }
    }

    return entropy
  }

  /**
   * Quarantine suspicious file
   * @param {Object} file - File object
   * @param {Object} scanResult - Scan result object
   */
  static async quarantineFile(file, scanResult) {
    try {
      // Ensure quarantine directory exists
      if (!existsSync(QUARANTINE_DIR)) {
        mkdirSync(QUARANTINE_DIR, { recursive: true })
      }

      // Generate quarantine filename
      const quarantineFilename = `${Date.now()}_${file.originalname}`
      const quarantinePath = join(QUARANTINE_DIR, quarantineFilename)

      // Move file to quarantine
      const fileContent = readFileSync(file.path)
      writeFileSync(quarantinePath, fileContent)

      // Create quarantine metadata
      const metadata = {
        originalFilename: file.originalname,
        quarantineFilename,
        quarantinePath,
        quarantinedAt: new Date().toISOString(),
        threats: scanResult.threats,
        fileHash: scanResult.fileHash,
        size: file.size,
        mimetype: file.mimetype
      }

      const metadataPath = join(QUARANTINE_DIR, `${quarantineFilename}.meta.json`)
      writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))

      // Remove original file
      unlinkSync(file.path)

      logger.warn('File quarantined', {
        originalFilename: file.originalname,
        quarantinePath,
        threats: scanResult.threats.length
      })

      scanResult.quarantinePath = quarantinePath
    } catch (error) {
      logger.error('Failed to quarantine file', {
        filename: file.originalname,
        error: error.message
      })
      throw new SecurityError('Failed to quarantine suspicious file', {
        filename: file.originalname,
        error: error.message
      })
    }
  }

  /**
   * Get quarantine statistics
   * @returns {Object} Quarantine statistics
   */
  static getQuarantineStats() {
    try {
      if (!existsSync(QUARANTINE_DIR)) {
        return {
          totalFiles: 0,
          totalSize: 0,
          threatsByType: {},
          oldestFile: null,
          newestFile: null
        }
      }

      // This would scan the quarantine directory and return statistics
      // For now, return placeholder data

      return {
        totalFiles: 0,
        totalSize: 0,
        threatsByType: {},
        oldestFile: null,
        newestFile: null
      }
    } catch (error) {
      logger.error('Failed to get quarantine stats', { error: error.message })
      return null
    }
  }

  /**
   * Get service statistics
   * @returns {Object} Service statistics
   */
  static getServiceStats() {
    return {
      allowedFileTypes: Object.keys(ALLOWED_FILE_TYPES),
      dangerousExtensionsCount: DANGEROUS_EXTENSIONS.length,
      suspiciousPatternsCount: SUSPICIOUS_PATTERNS.length,
      quarantineDirectory: QUARANTINE_DIR,
      clamAvEnabled: process.env.ENABLE_CLAMAV === 'true'
    }
  }
}

export default MalwareScanningService
