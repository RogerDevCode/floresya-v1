/**
 * Admin Panel Main Controller
 * Manages navigation and views for the admin panel
 */

import { initAdminCommon } from '../../js/admin-common.js'
import { toast } from '../../js/components/toast.js'

// Chart.js will be loaded via script tag in HTML
// Global state
let _currentView = 'dashboard'
let products = [] // Will be populated from API

/**
 * Load products from API
 * @param {boolean} includeInactive - Include inactive products (admin only)
 * @returns {Promise<Array>} Products array
 */
async function loadProducts(includeInactive = true) {
  try {
    const url = `/api/products?includeInactive=${includeInactive}`
    const response = await fetch(url, {
      headers: {
        Authorization: 'Bearer admin:1:admin' // Admin token for includeInactive
      }
    })

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const result = await response.json()

    if (!result.success || !result.data) {
      throw new Error(result.message || 'Failed to load products')
    }

    products = result.data

    // Load primary images (thumb size) for each product
    await loadProductImages(products)

    console.log(`✓ Loaded ${products.length} products from API`)
    return products
  } catch (error) {
    console.error('Error loading products:', error)
    toast.error('Error al cargar productos: ' + error.message)
    products = [] // Fail-fast: empty array on error
    return products
  }
}

/**
 * Load primary images for products
 * @param {Array} products - Products array
 */
async function loadProductImages(products) {
  try {
    // Load images for all products in parallel
    const imagePromises = products.map(async product => {
      try {
        // Get all images for product, filter by size=thumb
        const response = await fetch(`/api/products/${product.id}/images?size=thumb`, {
          headers: {
            Authorization: 'Bearer admin:1:admin'
          }
        })

        if (response.ok) {
          const result = await response.json()
          if (result.success && result.data && result.data.length > 0) {
            // Get primary thumb image (or first thumb image if none is primary)
            const primaryThumb = result.data.find(img => img.is_primary) || result.data[0]
            if (primaryThumb) {
              product.thumbnail_url = primaryThumb.url
            }
          }
        }
      } catch (error) {
        console.warn(`Failed to load image for product ${product.id}`)
      }
    })

    await Promise.all(imagePromises)
  } catch (error) {
    console.error('Error loading product images:', error)
  }
}

/**
 * Initialize admin panel
 */
function init() {
  // Initialize Lucide icons
  if (window.lucide && window.lucide.createIcons) {
    window.lucide.createIcons()
  }

  // Setup navigation
  setupNavigation()

  // Setup event listeners
  setupEventListeners()

  // Setup product form
  setupProductForm()

  // Load initial view
  showView('dashboard')
}

// ==================== DASHBOARD STATS ====================

let dashboardYearFilter = new Date().getFullYear().toString() // Default: año actual
let dashboardDateFilter = '' // Default: todos los períodos
let chartStatusFilter = 'all-non-cancelled' // Default: todos los pedidos no cancelados
let salesChartInstance = null // Chart.js instance

/**
 * Load dashboard data
 */
async function loadDashboardData() {
  setupDashboardFilters()
  setupChartFilter()
  await updateDashboardStats()
}

/**
 * Setup dashboard filter listeners
 */
function setupDashboardFilters() {
  const yearFilter = document.getElementById('dashboard-year-filter')
  const dateFilter = document.getElementById('dashboard-date-filter')

  if (yearFilter) {
    yearFilter.value = dashboardYearFilter
    yearFilter.addEventListener('change', e => {
      dashboardYearFilter = e.target.value
      updateDashboardStats()
    })
  }

  if (dateFilter) {
    dateFilter.addEventListener('change', e => {
      dashboardDateFilter = e.target.value
      updateDashboardStats()
    })
  }
}

/**
 * Apply dashboard filters to orders
 */
function applyDashboardFilters(orders) {
  let filtered = [...orders]

  // Filter by year
  if (dashboardYearFilter) {
    const year = parseInt(dashboardYearFilter)
    filtered = filtered.filter(order => {
      const orderYear = new Date(order.created_at).getFullYear()
      return orderYear === year
    })
  }

  // Filter by period
  if (dashboardDateFilter === 'today') {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    filtered = filtered.filter(order => new Date(order.created_at) >= today)
  } else if (dashboardDateFilter === 'current-month') {
    const now = new Date()
    const firstDay = new Date(now.getFullYear(), now.getMonth(), 1)
    filtered = filtered.filter(order => new Date(order.created_at) >= firstDay)
  } else if (dashboardDateFilter === 'last-month') {
    const now = new Date()
    const firstDayLastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1)
    const lastDayLastMonth = new Date(now.getFullYear(), now.getMonth(), 0)
    lastDayLastMonth.setHours(23, 59, 59, 999)
    filtered = filtered.filter(order => {
      const orderDate = new Date(order.created_at)
      return orderDate >= firstDayLastMonth && orderDate <= lastDayLastMonth
    })
  } else if (dashboardDateFilter && !isNaN(parseInt(dashboardDateFilter))) {
    const days = parseInt(dashboardDateFilter)
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - days)
    filtered = filtered.filter(order => new Date(order.created_at) >= cutoffDate)
  }

  return filtered
}

/**
 * Update filter indicator text
 */
function updateFilterIndicator() {
  const indicator = document.getElementById('dashboard-filter-indicator')
  if (!indicator) return

  const yearText = `Año ${dashboardYearFilter}`
  let periodText = 'Todos los pedidos'

  if (dashboardDateFilter === 'today') periodText = 'Día de hoy'
  else if (dashboardDateFilter === 'current-month') periodText = 'Este mes'
  else if (dashboardDateFilter === 'last-month') periodText = 'Mes pasado'
  else if (dashboardDateFilter === '30') periodText = 'Últimos 30 días'
  else if (dashboardDateFilter === '60') periodText = 'Últimos 60 días'
  else if (dashboardDateFilter === '90') periodText = 'Últimos 90 días'

  indicator.textContent = `Mostrando: ${yearText} | ${periodText}`
}

/**
 * Render monthly sales chart with Chart.js
 * @param {Array} orders - All orders from API
 */
function renderMonthlySalesChart(orders) {
  const canvas = document.getElementById('monthly-sales-chart')
  if (!canvas) return

  // Filter orders based on chart status filter
  let filteredOrders = [...orders]

  if (chartStatusFilter === 'all-non-cancelled') {
    filteredOrders = filteredOrders.filter(o => o.status !== 'cancelled')
  } else if (chartStatusFilter !== 'all') {
    filteredOrders = filteredOrders.filter(o => o.status === chartStatusFilter)
  }

  // Generate last 12 months from current month backwards
  const months = []
  const now = new Date()

  for (let i = 11; i >= 0; i--) {
    const date = new Date(now.getFullYear(), now.getMonth() - i, 1)
    const monthName = date.toLocaleDateString('es-ES', { month: 'short', year: 'numeric' })
    months.push({
      label: monthName.charAt(0).toUpperCase() + monthName.slice(1), // Capitalize
      year: date.getFullYear(),
      month: date.getMonth()
    })
  }

  // Calculate sales and order count per month
  const salesData = months.map(m => {
    const monthOrders = filteredOrders.filter(order => {
      const orderDate = new Date(order.created_at)
      return orderDate.getFullYear() === m.year && orderDate.getMonth() === m.month
    })

    const totalSales = monthOrders.reduce(
      (sum, order) => sum + parseFloat(order.total_amount_usd || 0),
      0
    )
    const orderCount = monthOrders.length

    return { totalSales, orderCount }
  })

  // Destroy existing chart if it exists
  if (salesChartInstance) {
    salesChartInstance.destroy()
  }

  // Create new chart
  const ctx = canvas.getContext('2d')
  salesChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: months.map(m => m.label),
      datasets: [
        {
          label: 'Monto USD',
          data: salesData.map(d => d.totalSales),
          backgroundColor: 'rgba(236, 72, 153, 0.5)', // Pink
          borderColor: 'rgba(236, 72, 153, 1)',
          borderWidth: 2,
          yAxisID: 'y-usd',
          order: 2
        },
        {
          label: 'Cantidad de Pedidos',
          data: salesData.map(d => d.orderCount),
          type: 'line',
          backgroundColor: 'rgba(168, 85, 247, 0.2)', // Purple
          borderColor: 'rgba(168, 85, 247, 1)',
          borderWidth: 2,
          pointBackgroundColor: 'rgba(168, 85, 247, 1)',
          pointRadius: 4,
          yAxisID: 'y-count',
          order: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'index',
        intersect: false
      },
      plugins: {
        legend: {
          display: true,
          position: 'top'
        },
        tooltip: {
          callbacks: {
            label: function (context) {
              let label = context.dataset.label || ''
              if (label) label += ': '
              if (context.datasetIndex === 0) {
                label += `$${context.parsed.y.toFixed(2)}`
              } else {
                label += context.parsed.y
              }
              return label
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false
          }
        },
        'y-usd': {
          type: 'linear',
          position: 'left',
          title: {
            display: true,
            text: 'Monto USD'
          },
          ticks: {
            callback: function (value) {
              return '$' + value.toFixed(0)
            }
          }
        },
        'y-count': {
          type: 'linear',
          position: 'right',
          title: {
            display: true,
            text: 'Cantidad'
          },
          grid: {
            drawOnChartArea: false
          },
          ticks: {
            stepSize: 1
          }
        }
      }
    }
  })

  // Update subtitle based on filter
  updateChartSubtitle()
}

/**
 * Update chart subtitle based on active filter
 */
function updateChartSubtitle() {
  const subtitle = document.getElementById('chart-subtitle')
  if (!subtitle) return

  let text = 'Últimos 12 meses'

  if (chartStatusFilter === 'all-non-cancelled') {
    text += ' (pedidos no cancelados)'
  } else if (chartStatusFilter === 'all') {
    text += ' (todos los pedidos)'
  } else {
    const statusNames = {
      pending: 'Pendientes',
      verified: 'Verificados',
      preparing: 'Preparando',
      shipped: 'Enviados',
      delivered: 'Entregados',
      cancelled: 'Cancelados'
    }
    text += ` (solo ${statusNames[chartStatusFilter] || chartStatusFilter})`
  }

  subtitle.textContent = text
}

/**
 * Setup chart filter listener
 */
function setupChartFilter() {
  const chartFilter = document.getElementById('chart-status-filter')
  if (!chartFilter) return

  chartFilter.addEventListener('change', async e => {
    chartStatusFilter = e.target.value

    // Re-fetch orders and re-render chart
    try {
      const ordersResponse = await fetch('/api/orders', {
        headers: { Authorization: 'Bearer admin:1:admin' }
      })

      if (!ordersResponse.ok) {
        throw new Error('Failed to fetch orders')
      }

      const ordersData = await ordersResponse.json()
      const allOrders = ordersData.success ? ordersData.data : []

      renderMonthlySalesChart(allOrders)
    } catch (error) {
      console.error('Error re-rendering chart:', error)
    }
  })
}

/**
 * Get top products by quantity sold
 * @param {Array} orders - All orders from API
 * @param {Number} limit - Number of top products to return (default: 3)
 * @returns {Array} - Top products with sales count
 */
function getTopProducts(orders, limit = 3) {
  // Filter: exclude cancelled orders + apply global filters
  const filteredOrders = applyDashboardFilters(orders).filter(o => o.status !== 'cancelled')

  // Group by product_id and sum quantities
  const productSales = {}

  filteredOrders.forEach(order => {
    if (!order.order_items || !Array.isArray(order.order_items)) return

    order.order_items.forEach(item => {
      const productId = item.product_id
      const productName = item.product_name
      const quantity = parseInt(item.quantity) || 0

      if (!productSales[productId]) {
        productSales[productId] = {
          product_id: productId,
          product_name: productName,
          total_quantity: 0
        }
      }

      productSales[productId].total_quantity += quantity
    })
  })

  // Convert to array and sort by quantity DESC
  const sortedProducts = Object.values(productSales).sort(
    (a, b) => b.total_quantity - a.total_quantity
  )

  // Return top N
  return sortedProducts.slice(0, limit)
}

/**
 * Render top products section
 * @param {Array} topProducts - Top products from getTopProducts()
 */
function renderTopProducts(topProducts) {
  const container = document.getElementById('top-products-list')
  if (!container) return

  if (!topProducts || topProducts.length === 0) {
    container.innerHTML = `
      <div class="text-center text-gray-500 py-8">
        <i data-lucide="package-x" class="h-8 w-8 mx-auto"></i>
        <p class="mt-2">No hay datos de productos vendidos</p>
      </div>
    `
    // Reinitialize icons
    if (window.lucide && window.lucide.createIcons) {
      window.lucide.createIcons()
    }
    return
  }

  container.innerHTML = topProducts
    .map(
      (product, index) => `
    <div class="flex items-center justify-between border-b pb-3">
      <div class="flex items-center gap-3">
        <div class="flex-shrink-0 w-10 h-10 bg-gradient-to-br from-pink-500 to-purple-600 rounded-lg flex items-center justify-center text-white font-bold text-lg">
          ${index + 1}
        </div>
        <div>
          <p class="font-medium text-gray-900">${product.product_name}</p>
          <p class="text-sm text-gray-500">ID: ${product.product_id}</p>
        </div>
      </div>
      <div class="text-right">
        <p class="font-bold text-gray-900 text-lg">${product.total_quantity}</p>
        <p class="text-xs text-gray-500">unidades</p>
      </div>
    </div>
  `
    )
    .join('')

  // Update subtitle
  updateTopProductsSubtitle()
}

/**
 * Update top products subtitle based on active filters
 */
function updateTopProductsSubtitle() {
  const subtitle = document.getElementById('top-products-subtitle')
  if (!subtitle) return

  const yearText = `Año ${dashboardYearFilter}`
  let periodText = 'Todos los pedidos'

  if (dashboardDateFilter === 'today') periodText = 'Día de hoy'
  else if (dashboardDateFilter === 'current-month') periodText = 'Este mes'
  else if (dashboardDateFilter === 'last-month') periodText = 'Mes pasado'
  else if (dashboardDateFilter === '30') periodText = 'Últimos 30 días'
  else if (dashboardDateFilter === '60') periodText = 'Últimos 60 días'
  else if (dashboardDateFilter === '90') periodText = 'Últimos 90 días'

  subtitle.textContent = `Filtros: ${yearText} | ${periodText} (excluye cancelados)`
}

/**
 * Update dashboard statistics with real API data
 */
async function updateDashboardStats() {
  try {
    // Fetch orders from API
    const ordersResponse = await fetch('/api/orders', {
      headers: { Authorization: 'Bearer admin:1:admin' }
    })

    if (!ordersResponse.ok) {
      throw new Error('Failed to fetch orders from API')
    }

    const ordersData = await ordersResponse.json()
    let allOrders = ordersData.success ? ordersData.data : []

    // Apply filters
    const filteredOrders = applyDashboardFilters(allOrders)

    // Calculate stats by status
    const stats = {
      pending: filteredOrders.filter(o => o.status === 'pending').length,
      verified: filteredOrders.filter(o => o.status === 'verified').length,
      preparing: filteredOrders.filter(o => o.status === 'preparing').length,
      shipped: filteredOrders.filter(o => o.status === 'shipped').length,
      delivered: filteredOrders.filter(o => o.status === 'delivered').length,
      cancelled: filteredOrders.filter(o => o.status === 'cancelled').length
    }

    // Total orders (includes cancelled)
    const totalOrders = filteredOrders.length

    // Total sales (excludes cancelled)
    const totalSales = filteredOrders
      .filter(o => o.status !== 'cancelled')
      .reduce((sum, order) => sum + parseFloat(order.total_amount_usd || 0), 0)

    // Update DOM
    const updateElement = (id, value) => {
      const el = document.getElementById(id)
      if (el) el.textContent = value
    }

    updateElement('dash-total-orders', totalOrders)
    updateElement('dash-total-sales', `$${totalSales.toFixed(2)}`)
    updateElement('dash-status-pending', stats.pending)
    updateElement('dash-status-verified', stats.verified)
    updateElement('dash-status-preparing', stats.preparing)
    updateElement('dash-status-shipped', stats.shipped)
    updateElement('dash-status-delivered', stats.delivered)
    updateElement('dash-status-cancelled', stats.cancelled)

    // Update filter indicator
    updateFilterIndicator()

    // Render monthly sales chart
    renderMonthlySalesChart(allOrders)

    // Render top products
    const topProducts = getTopProducts(allOrders, 3)
    renderTopProducts(topProducts)

    console.log('✓ Dashboard stats updated:', { totalOrders, totalSales, stats, topProducts })
  } catch (error) {
    console.error('Error loading dashboard stats:', error)
    showDashboardError()
  }
}

/**
 * Show error state in dashboard stats
 */
function showDashboardError() {
  const elements = [
    'dash-total-products',
    'dash-total-orders',
    'dash-total-sales',
    'dash-pending-orders'
  ]

  elements.forEach(id => {
    const el = document.getElementById(id)
    if (el) {
      el.textContent = 'Error'
      el.classList.add('text-red-600')
    }
  })
}

/**
 * Setup navigation between admin sections
 */
function setupNavigation() {
  // Get all sidebar menu items
  const menuItems = document.querySelectorAll('.sidebar-menu-item')
  menuItems.forEach(item => {
    item.addEventListener('click', e => {
      const view = item.getAttribute('data-view')

      // Only prevent default and handle view switching for items with data-view
      if (view) {
        e.preventDefault()
        showView(view)

        // Update active class
        menuItems.forEach(menuItem => menuItem.classList.remove('active'))
        item.classList.add('active')
      }
      // Items without data-view (with href) will navigate normally
    })
  })
}

/**
 * Setup event listeners
 */
function setupEventListeners() {
  // Apply filters button
  const applyFiltersBtn = document.getElementById('apply-filters-btn')
  if (applyFiltersBtn) {
    applyFiltersBtn.addEventListener('click', () => {
      filterProducts()
    })
  }

  // Clear filters button
  const clearFiltersBtn = document.getElementById('clear-filters-btn')
  if (clearFiltersBtn) {
    clearFiltersBtn.addEventListener('click', () => {
      clearFilters()
    })
  }

  // Auto-filter on search input (Enter key)
  const searchInput = document.getElementById('search-input')
  if (searchInput) {
    searchInput.addEventListener('keyup', e => {
      if (e.key === 'Enter') {
        filterProducts()
      }
    })
  }

  // Auto-filter on occasion change
  const occasionFilter = document.getElementById('occasion-filter')
  if (occasionFilter) {
    occasionFilter.addEventListener('change', () => {
      filterProducts()
    })
  }

  // Auto-filter on status change
  const statusFilter = document.getElementById('status-filter')
  if (statusFilter) {
    statusFilter.addEventListener('change', () => {
      filterProducts()
    })
  }

  // Open contact editor button
  const openContactBtn = document.getElementById('open-contact-editor-btn')
  if (openContactBtn) {
    openContactBtn.addEventListener('click', () => {
      // Redirect to the existing contact editor page
      window.location.href = 'contact-editor.html'
    })
  }

  // Logout button
  const logoutBtn = document.getElementById('logout-btn')
  if (logoutBtn) {
    logoutBtn.addEventListener('click', () => {
      if (confirm('¿Estás seguro de que deseas cerrar sesión?')) {
        // Simulate logout
        alert('Sesión cerrada. Redirigiendo al login...')
        window.location.href = '/' // Redirect to home or login page
      }
    })
  }

  // Global keyboard shortcuts
  setupKeyboardShortcuts()
}

/**
 * Setup global keyboard shortcuts
 */
function setupKeyboardShortcuts() {
  document.addEventListener('keydown', e => {
    // ESC - Close product form modal
    if (e.key === 'Escape') {
      const modal = document.getElementById('product-form-modal')
      if (modal && !modal.classList.contains('hidden')) {
        closeProductForm()
      }
    }
  })
}

/**
 * Show specified view and hide others
 */
async function showView(view) {
  _currentView = view

  // Hide all views
  const views = document.querySelectorAll('[id$="-view"]')
  views.forEach(viewElement => {
    viewElement.classList.add('hidden')
  })

  // Show requested view
  const requestedView = document.getElementById(`${view}-view`)
  if (requestedView) {
    requestedView.classList.remove('hidden')
  }

  // Special handling for dashboard view
  if (view === 'dashboard') {
    loadDashboardData()
  }

  // Special handling for products view
  if (view === 'products') {
    await loadProducts() // Fetch from API
    await loadOccasionsFilter() // Load occasions for filter
    renderProducts(products)
  }

  // Special handling for occasions view
  if (view === 'occasions') {
    // Load occasions data when showing the view
    if (window.occasionsModule && window.occasionsModule.loadOccasionsData) {
      window.occasionsModule.loadOccasionsData()
    }
  }
}

/**
 * Clear all filters and show all products
 */
function clearFilters() {
  // Reset all filter inputs
  const searchInput = document.getElementById('search-input')
  const occasionFilter = document.getElementById('occasion-filter')
  const statusFilter = document.getElementById('status-filter')

  if (searchInput) searchInput.value = ''
  if (occasionFilter) occasionFilter.value = ''
  if (statusFilter) statusFilter.value = ''

  // Show all products
  renderProducts(products)
}

/**
 * Load occasions for filter dropdown
 */
async function loadOccasionsFilter() {
  try {
    const response = await fetch('/api/occasions', {
      headers: {
        Authorization: 'Bearer admin:1:admin'
      }
    })

    if (!response.ok) {
      console.warn('Failed to load occasions for filter')
      return
    }

    const result = await response.json()
    if (!result.success || !result.data) {
      console.warn('No occasions data received')
      return
    }

    const occasions = result.data.filter(occ => occ.is_active)
    const select = document.getElementById('occasion-filter')

    if (!select) {
      console.error('Occasion filter select not found')
      return
    }

    // Clear existing options (except "Todas")
    select.innerHTML = '<option value="">Todas las ocasiones</option>'

    // Add occasion options
    occasions.forEach(occasion => {
      const option = document.createElement('option')
      option.value = occasion.id
      option.textContent = occasion.name
      select.appendChild(option)
    })

    console.log(`✓ Loaded ${occasions.length} occasions for filter`)
  } catch (error) {
    console.error('Error loading occasions filter:', error)
  }
}

/**
 * Filter products based on search criteria
 */
async function filterProducts() {
  const searchInput = document.getElementById('search-input')
  const occasionFilter = document.getElementById('occasion-filter')
  const statusFilter = document.getElementById('status-filter')

  if (!searchInput || !occasionFilter || !statusFilter) {
    console.error('Filter elements not found')
    return
  }

  const searchTerm = searchInput.value.toLowerCase()
  const occasionId = occasionFilter.value
  const status = statusFilter.value

  let filtered = [...products]

  // Text search
  if (searchTerm) {
    filtered = filtered.filter(
      product =>
        product.name.toLowerCase().includes(searchTerm) ||
        (product.description && product.description.toLowerCase().includes(searchTerm)) ||
        (product.sku && product.sku.toLowerCase().includes(searchTerm))
    )
  }

  // Filter by occasion (requires checking product_occasions relationship)
  if (occasionId) {
    try {
      console.log(`Filtering by occasion ID: ${occasionId}`)
      // Fetch products for this occasion from API
      const response = await fetch(`/api/products/occasion/${occasionId}`, {
        headers: {
          Authorization: 'Bearer admin:1:admin'
        }
      })

      if (response.ok) {
        const result = await response.json()
        console.log(`Products for occasion ${occasionId}:`, result.data.length)
        const occasionProductIds = result.data.map(p => p.id)

        // Filter local products to only those in this occasion
        const beforeCount = filtered.length
        filtered = filtered.filter(product => occasionProductIds.includes(product.id))
        console.log(`Filtered: ${beforeCount} → ${filtered.length} products`)
      } else {
        console.warn('Failed to fetch products for occasion:', occasionId, response.status)
        toast.warning('No se pudieron cargar productos para esta ocasión')
      }
    } catch (error) {
      console.error('Error filtering by occasion:', error)
      toast.error('Error al filtrar por ocasión')
    }
  }

  // Filter by status
  if (status) {
    filtered = filtered.filter(product => (status === 'active' ? product.active : !product.active))
  }

  renderProducts(filtered)
}

/**
 * Render products in the table
 */
function renderProducts(products) {
  const productsList = document.getElementById('products-list')
  if (!productsList) {
    return
  }

  productsList.innerHTML = ''

  // Placeholder images for cycling (relative to /public/pages/admin/)
  const placeholders = ['../../images/placeholder-flower.svg', '../../images/placeholder-hero.svg']
  let placeholderIndex = 0

  products.forEach(product => {
    const row = document.createElement('tr')

    // Determine status badge class
    let statusClass = 'px-2 inline-flex text-xs leading-5 font-semibold rounded-full '
    statusClass += product.active ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'

    // Get image URL - cycle through placeholders if no thumbnail
    let imageUrl = product.thumbnail_url
    if (!imageUrl) {
      imageUrl = placeholders[placeholderIndex % placeholders.length]
      placeholderIndex++
    }

    row.innerHTML = `
      <td class="px-6 py-4">
        <div class="flex items-center gap-3">
          <div class="flex-shrink-0 h-12 w-12">
            <img class="h-12 w-12 rounded-md object-cover" src="${imageUrl}" alt="${product.name}">
          </div>
          <div class="min-w-0 flex-1">
            <div class="text-sm font-semibold text-gray-900 truncate">${product.name}</div>
            <div class="text-xs text-gray-500 mt-0.5">${product.sku || 'Sin SKU'}</div>
          </div>
        </div>
      </td>
      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
        $${product.price_usd.toFixed(2)}
      </td>
      <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
        ${product.stock}
      </td>
      <td class="px-6 py-4 whitespace-nowrap">
        <span class="${statusClass}">
          ${product.active ? 'Activo' : 'Inactivo'}
        </span>
      </td>
      <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
        <a
          href="./edit-product.html?id=${product.id}"
          class="text-indigo-600 hover:text-indigo-900"
        >
          Editar
        </a>
        <a 
          href="#" 
          class="ml-4 text-red-600 hover:text-red-900 delete-product-link"
          data-product-id="${product.id}"
        >
          Eliminar
        </a>
      </td>
    `

    productsList.appendChild(row)
  })

  // Add event listeners to edit links
  document.querySelectorAll('.edit-product-link').forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault()
      const productId = parseInt(e.target.getAttribute('data-product-id'), 10)
      if (!productId || isNaN(productId)) {
        console.error('Invalid product ID')
        return
      }
      editProduct(productId)
    })
  })

  // Add event listeners to delete links
  document.querySelectorAll('.delete-product-link').forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault()
      const productId = parseInt(e.target.getAttribute('data-product-id'), 10)
      if (!productId || isNaN(productId)) {
        console.error('Invalid product ID')
        return
      }
      deleteProduct(productId)
    })
  })
}

/**
 * Edit product (opens form modal in edit mode)
 */
function editProduct(productId) {
  openProductForm(productId)
}

/**
 * Delete product (soft delete - mark as inactive)
 */
function deleteProduct(productId) {
  if (!confirm('¿Estás seguro de que deseas desactivar este producto?')) {
    return
  }

  const product = products.find(p => p.id === productId)
  if (!product) {
    console.error('Product not found:', productId)
    toast.error('Producto no encontrado')
    return
  }

  product.active = false
  product.updated_at = new Date().toISOString()
  renderProducts(products)
  toast.success('Producto desactivado exitosamente')
}

// ==================== PRODUCT FORM MANAGEMENT ====================

/**
 * Product images state
 * Array of { file: File, preview: string, index: number, isPrimary: boolean }
 */
let productImages = []
let currentEditingProductId = null

/**
 * Open product form modal
 * @param {number|null} productId - null for CREATE, number for EDIT
 */
async function openProductForm(productId = null) {
  const modal = document.getElementById('product-form-modal')
  const title = document.getElementById('product-form-title')
  const form = document.getElementById('product-form')

  // Reset form
  form.reset()
  productImages = []
  currentEditingProductId = productId

  if (productId) {
    // EDIT mode
    title.textContent = 'Editar Producto'
    const product = products.find(p => p.id === productId)
    if (product) {
      // Populate form fields
      document.getElementById('product-name').value = product.name || ''
      document.getElementById('product-description').value = product.description || ''
      document.getElementById('product-sku').value = product.sku || ''
      document.getElementById('product-price-usd').value = product.price_usd || ''
      document.getElementById('product-price-ves').value = product.price_ves || ''
      document.getElementById('product-stock').value = product.stock || 0
      document.getElementById('product-featured').checked = product.featured || false
      document.getElementById('product-carousel-order').value = product.carousel_order || ''

      // Load existing images from API
      await loadExistingImages(productId)
    }
  } else {
    // CREATE mode
    title.textContent = 'Nuevo Producto'
  }

  // Render image grid
  renderImageGrid()

  // Load occasions
  loadOccasions()

  // Show modal
  modal.classList.remove('hidden')

  // Reinitialize icons
  if (window.lucide && window.lucide.createIcons) {
    window.lucide.createIcons()
  }
}

/**
 * Load existing images for a product (EDIT mode)
 * @param {number} productId
 */
async function loadExistingImages(productId) {
  try {
    const response = await fetch(`/api/products/${productId}/images`, {
      headers: {
        Authorization: 'Bearer admin:1:admin'
      }
    })

    if (!response.ok) {
      console.warn(`Failed to load images for product ${productId}`)
      return
    }

    const result = await response.json()
    if (!result.success || !result.data) {
      console.warn('No images found for product')
      return
    }

    const images = result.data

    // Group images by image_index
    const imagesByIndex = {}
    images.forEach(img => {
      if (!imagesByIndex[img.image_index]) {
        imagesByIndex[img.image_index] = []
      }
      imagesByIndex[img.image_index].push(img)
    })

    // Convert to productImages format (use medium size for display)
    productImages = []
    Object.keys(imagesByIndex).forEach(index => {
      const imageGroup = imagesByIndex[index]
      const mediumImage = imageGroup.find(img => img.size === 'medium')
      if (mediumImage) {
        productImages.push({
          index: parseInt(index),
          preview: mediumImage.url,
          isPrimary: mediumImage.is_primary,
          existingImageIndex: parseInt(index), // Mark as existing
          file: null // No file object for existing images
        })
      }
    })

    console.log(`✓ Loaded ${productImages.length} existing images for product ${productId}`)
  } catch (error) {
    console.error('Error loading existing images:', error)
    toast.error('Error al cargar imágenes del producto')
  }
}

/**
 * Close product form modal
 */
function closeProductForm() {
  const modal = document.getElementById('product-form-modal')
  modal.classList.add('hidden')
  productImages = []
  currentEditingProductId = null
}

/**
 * Render image grid (5 slots)
 */
function renderImageGrid() {
  const grid = document.getElementById('product-images-grid')
  grid.innerHTML = ''

  for (let i = 0; i < 5; i++) {
    const image = productImages.find(img => img.index === i)
    const slot = createImageSlot(i, image)
    grid.appendChild(slot)
  }

  // Reinitialize icons
  if (window.lucide && window.lucide.createIcons) {
    window.lucide.createIcons()
  }
}

/**
 * Create image slot element
 * @param {number} index - Slot index (0-4)
 * @param {object|null} image - Image data or null if empty
 */
function createImageSlot(index, image) {
  const slot = document.createElement('div')
  slot.className = 'image-slot'
  slot.dataset.index = index

  if (image) {
    // Slot with image
    slot.classList.add('has-image')
    if (image.isPrimary) {
      slot.classList.add('is-primary')
    }

    // Make draggable
    slot.draggable = true

    slot.innerHTML = `
      <img src="${image.preview}" alt="Product image ${index + 1}" class="image-slot-preview">
      <div class="image-slot-index">#${index + 1}</div>
      <div class="image-slot-overlay">
        <button type="button" class="image-slot-btn primary set-primary-btn" data-index="${index}" title="Marcar como principal">
          <i data-lucide="star" class="h-5 w-5"></i>
        </button>
        <button type="button" class="image-slot-btn remove remove-image-btn" data-index="${index}" title="Eliminar imagen">
          <i data-lucide="trash-2" class="h-5 w-5"></i>
        </button>
      </div>
    `

    // Drag event listeners
    slot.addEventListener('dragstart', handleDragStart)
    slot.addEventListener('dragend', handleDragEnd)
  } else {
    // Empty slot
    slot.innerHTML = `
      <div class="image-slot-placeholder">
        <i data-lucide="plus" class="h-8 w-8"></i>
        <span class="text-xs">Agregar imagen</span>
      </div>
    `
    slot.addEventListener('click', () => openFilePicker(index))
  }

  // Drop zone for all slots
  slot.addEventListener('dragover', handleDragOver)
  slot.addEventListener('drop', handleDrop)
  slot.addEventListener('dragleave', handleDragLeave)

  return slot
}

/**
 * Open file picker for specific slot
 * @param {number} index - Slot index
 */
function openFilePicker(index) {
  const input = document.getElementById('product-image-upload')
  input.dataset.targetIndex = index
  input.click()
}

/**
 * Handle file selection
 */
function handleFileSelect(event) {
  const files = event.target.files
  const targetIndex = parseInt(event.target.dataset.targetIndex)

  if (!files || files.length === 0) return

  const file = files[0]

  // Validate file type
  if (!file.type.match('image/(jpeg|jpg|png|webp)')) {
    toast.error('Solo se permiten imágenes JPEG, PNG o WebP')
    return
  }

  // Validate file size (max 4MB - Vercel serverless limit)
  if (file.size > 4 * 1024 * 1024) {
    toast.error('El tamaño máximo de imagen es 4MB (límite de Vercel)')
    return
  }

  // Create preview
  const reader = new FileReader()
  reader.onload = e => {
    const img = new Image()
    img.onload = () => {
      // Validate dimensions (min 1200x1200)
      if (img.width < 1200 || img.height < 1200) {
        if (
          !confirm(
            `La imagen es ${img.width}x${img.height}px. Se recomienda al menos 1200x1200px. ¿Continuar?`
          )
        ) {
          return
        }
      }

      // Add image to array
      const isPrimary = productImages.length === 0 // First image is primary
      productImages.push({
        file: file,
        preview: e.target.result,
        index: targetIndex,
        isPrimary: isPrimary
      })

      // Re-render grid
      renderImageGrid()
    }

    img.src = e.target.result
  }

  reader.readAsDataURL(file)

  // Reset input
  event.target.value = ''
}

/**
 * Set image as primary
 * @param {number} index - Image index
 */
function setPrimaryImage(index) {
  productImages.forEach(img => {
    img.isPrimary = img.index === index
  })
  renderImageGrid()
}

/**
 * Remove image
 * @param {number} index - Image index
 */
async function removeImage(index) {
  if (!confirm('¿Eliminar esta imagen?')) return

  const image = productImages.find(img => img.index === index)

  // If editing and image exists on server, delete from API
  if (currentEditingProductId && image && image.existingImageIndex !== undefined) {
    try {
      const response = await fetch(
        `/api/products/${currentEditingProductId}/images/${image.existingImageIndex}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: 'Bearer admin:1:admin'
          }
        }
      )

      if (!response.ok) {
        throw new Error('Failed to delete image from server')
      }

      toast.success('Imagen eliminada del servidor')
    } catch (error) {
      console.error('Error deleting image:', error)
      toast.error('Error al eliminar imagen del servidor')
      return // Don't remove from local array if API call failed
    }
  }

  // Remove from local array
  productImages = productImages.filter(img => img.index !== index)

  // If removed image was primary, set first image as primary
  if (productImages.length > 0 && !productImages.some(img => img.isPrimary)) {
    productImages[0].isPrimary = true
  }

  renderImageGrid()
}

/**
 * Upload product images to server (REAL FILE UPLOAD)
 * Only uploads NEW images (with file object)
 * @param {number} productId - Product ID to attach images to
 */
async function uploadProductImages(productId) {
  try {
    // Filter only NEW images (with file object)
    const newImages = productImages.filter(img => img.file !== null && img.file !== undefined)

    if (newImages.length === 0) {
      console.log('No new images to upload')
      return
    }

    console.log(`Uploading ${newImages.length} new images for product ${productId}`)

    // Sort images by index
    const sortedImages = [...newImages].sort((a, b) => a.index - b.index)

    for (const imageData of sortedImages) {
      // Create FormData for multipart/form-data upload
      const formData = new FormData()
      formData.append('image', imageData.file) // The actual File object
      formData.append('image_index', imageData.index + 1) // API expects 1-5, we use 0-4
      formData.append('is_primary', imageData.isPrimary)

      // Upload to API (multipart/form-data)
      const response = await fetch(`/api/products/${productId}/images`, {
        method: 'POST',
        headers: {
          Authorization: 'Bearer admin:1:admin'
          // Note: Do NOT set Content-Type header - browser will set it with boundary
        },
        body: formData
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || `Failed to upload image ${imageData.index + 1}`)
      }

      const result = await response.json()
      console.log(`✓ Image ${imageData.index + 1} uploaded:`, result.message)
    }

    console.log(`✓ All ${sortedImages.length} new images uploaded successfully`)
  } catch (error) {
    console.error('Error uploading images:', error)
    throw error
  }
}

// ==================== DRAG & DROP IMAGE REORDERING ====================

/**
 * Drag & drop state
 */
let draggedImageIndex = null

/**
 * Handle drag start
 */
function handleDragStart(e) {
  draggedImageIndex = parseInt(e.currentTarget.dataset.index)
  e.currentTarget.classList.add('dragging')
  e.dataTransfer.effectAllowed = 'move'
}

/**
 * Handle drag end
 */
function handleDragEnd(e) {
  e.currentTarget.classList.remove('dragging')
  // Remove drag-over class from all slots
  document.querySelectorAll('.image-slot').forEach(slot => {
    slot.classList.remove('drag-over')
  })
}

/**
 * Handle drag over
 */
function handleDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault()
  }
  e.dataTransfer.dropEffect = 'move'
  e.currentTarget.classList.add('drag-over')
  return false
}

/**
 * Handle drag leave
 */
function handleDragLeave(e) {
  e.currentTarget.classList.remove('drag-over')
}

/**
 * Handle drop
 */
function handleDrop(e) {
  if (e.stopPropagation) {
    e.stopPropagation()
  }
  e.preventDefault()

  const dropIndex = parseInt(e.currentTarget.dataset.index)

  if (draggedImageIndex !== null && draggedImageIndex !== dropIndex) {
    // Find the images
    const draggedImage = productImages.find(img => img.index === draggedImageIndex)
    const dropImage = productImages.find(img => img.index === dropIndex)

    if (draggedImage) {
      // Swap indices
      draggedImage.index = dropIndex
      if (dropImage) {
        dropImage.index = draggedImageIndex
      }

      // Re-render grid
      renderImageGrid()
    }
  }

  draggedImageIndex = null
  return false
}

/**
 * Load occasions from API
 */
async function loadOccasions() {
  const container = document.getElementById('occasions-list')

  try {
    const response = await fetch('/api/occasions')
    const result = await response.json()

    if (!result.success || !result.data) {
      throw new Error('Failed to load occasions')
    }

    const occasions = result.data

    container.innerHTML = occasions
      .map(
        occasion => `
      <label class="flex items-center space-x-2 cursor-pointer p-2 hover:bg-gray-50 rounded-lg transition-colors">
        <input type="checkbox" name="occasions" value="${occasion.id}"
               class="h-4 w-4 text-pink-600 focus:ring-pink-500 border-gray-300 rounded">
        <span class="text-sm text-gray-700">${occasion.name}</span>
      </label>
    `
      )
      .join('')
  } catch (error) {
    console.error('Error loading occasions:', error)
    container.innerHTML =
      '<p class="text-sm text-red-600 col-span-full">Error al cargar ocasiones</p>'
  }
}

/**
 * Handle form submission
 */
async function handleProductFormSubmit(event) {
  event.preventDefault()

  const form = event.target
  const formData = new FormData(form)

  // Collect form data
  const productData = {
    name: formData.get('name'),
    description: formData.get('description') || null,
    price_usd: parseFloat(formData.get('price_usd')),
    price_ves: formData.get('price_ves') ? parseFloat(formData.get('price_ves')) : null,
    stock: parseInt(formData.get('stock')) || 0,
    sku: formData.get('sku') || null,
    featured: formData.get('featured') === 'on',
    carousel_order: formData.get('carousel_order') ? parseInt(formData.get('carousel_order')) : null
  }

  // Collect occasion IDs
  const occasionIds = Array.from(form.querySelectorAll('input[name="occasions"]:checked')).map(cb =>
    parseInt(cb.value)
  )

  // Validate
  if (!productData.name || productData.name.length < 2) {
    toast.error('El nombre del producto debe tener al menos 2 caracteres')
    return
  }

  if (productData.price_usd < 0) {
    toast.error('El precio USD debe ser mayor o igual a 0')
    return
  }

  // Validate images: must have at least 1 image (for CREATE and EDIT)
  // Note: productImages includes both new images (with file) and existing images (without file)
  if (productImages.length === 0) {
    toast.error('Debes agregar al menos 1 imagen al producto')
    return
  }

  // Validate images: max 5 images
  if (productImages.length > 5) {
    toast.error('Un producto no puede tener más de 5 imágenes')
    return
  }

  try {
    // Show loading
    const saveBtn = document.getElementById('save-product-btn')
    const originalText = saveBtn.innerHTML
    saveBtn.disabled = true
    saveBtn.innerHTML =
      '<i data-lucide="loader" class="h-5 w-5 animate-spin"></i> <span>Guardando...</span>'
    if (window.lucide && window.lucide.createIcons) {
      window.lucide.createIcons()
    }

    let result

    if (currentEditingProductId) {
      // EDIT mode - PUT /api/products/:id
      const endpoint = `/api/products/${currentEditingProductId}`
      const response = await fetch(endpoint, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer admin:1:admin'
        },
        body: JSON.stringify(productData)
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || `HTTP ${response.status}`)
      }

      result = await response.json()

      // Update local data
      const product = products.find(p => p.id === currentEditingProductId)
      if (product) {
        Object.assign(product, productData)
        product.updated_at = new Date().toISOString()
      }
    } else {
      // CREATE mode
      let endpoint = '/api/products'
      let requestBody = productData

      // Use /with-occasions if occasions selected
      if (occasionIds.length > 0) {
        endpoint = '/api/products/with-occasions'
        requestBody = {
          product: productData,
          occasionIds: occasionIds
        }
      }

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer admin:1:admin'
        },
        body: JSON.stringify(requestBody)
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || `HTTP ${response.status}`)
      }

      result = await response.json()

      // Add to local data
      const newProduct = {
        id: result.data?.id || (products.length > 0 ? Math.max(...products.map(p => p.id)) + 1 : 1),
        ...productData,
        active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        image_url: productImages.length > 0 ? productImages[0].preview : null
      }
      products.push(newProduct)
    }

    console.log('✓ Product saved:', result)

    // Upload images if any (use currentEditingProductId in EDIT mode, result.data.id in CREATE mode)
    const productId = currentEditingProductId || result.data?.id
    if (productImages.length > 0 && productId) {
      await uploadProductImages(productId)
    }

    // Success - restore button BEFORE closing modal
    if (saveBtn) {
      saveBtn.disabled = false
      saveBtn.innerHTML = '<i data-lucide="save" class="h-5 w-5"></i> <span>Guardar Producto</span>'
      if (window.lucide && window.lucide.createIcons) {
        window.lucide.createIcons()
      }
    }

    toast.success(`Producto ${currentEditingProductId ? 'actualizado' : 'creado'} exitosamente`)
    closeProductForm()

    // Reload products in background (don't await to avoid blocking)
    loadProducts()
      .then(() => {
        renderProducts(products)
      })
      .catch(err => {
        console.error('Error reloading products:', err)
      })
  } catch (error) {
    console.error('Error saving product:', error)
    toast.error('Error al guardar el producto: ' + error.message)

    // Restore button
    const saveBtn = document.getElementById('save-product-btn')
    saveBtn.disabled = false
    saveBtn.innerHTML = '<i data-lucide="save" class="h-5 w-5"></i> <span>Guardar Producto</span>'
    if (window.lucide && window.lucide.createIcons) {
      window.lucide.createIcons()
    }
  }
}

/**
 * Setup product form event listeners
 */
function setupProductForm() {
  // Open form when clicking "Nuevo Producto"
  const newProductBtn = document.getElementById('new-product-btn')
  if (newProductBtn) {
    newProductBtn.addEventListener('click', () => openProductForm())
  }

  // Close form buttons
  const closeBtn = document.getElementById('close-product-form')
  const cancelBtn = document.getElementById('cancel-product-form')

  if (closeBtn) {
    closeBtn.addEventListener('click', closeProductForm)
  }

  if (cancelBtn) {
    cancelBtn.addEventListener('click', closeProductForm)
  }

  // Form submission
  const form = document.getElementById('product-form')
  if (form) {
    form.addEventListener('submit', handleProductFormSubmit)
  }

  // File input
  const fileInput = document.getElementById('product-image-upload')
  if (fileInput) {
    fileInput.addEventListener('change', handleFileSelect)
  }

  // Image grid event delegation
  const imageGrid = document.getElementById('product-images-grid')
  if (imageGrid) {
    imageGrid.addEventListener('click', event => {
      const setPrimaryBtn = event.target.closest('.set-primary-btn')
      const removeBtn = event.target.closest('.remove-image-btn')

      if (setPrimaryBtn) {
        const index = parseInt(setPrimaryBtn.dataset.index)
        setPrimaryImage(index)
      } else if (removeBtn) {
        const index = parseInt(removeBtn.dataset.index)
        removeImage(index)
      }
    })
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Initialize icons first
  if (window.lucide && window.lucide.createIcons) {
    window.lucide.createIcons()
  }

  // Then initialize admin functionality
  init()
  initAdminCommon()

  // Initialize occasions module
  if (window.occasionsModule && window.occasionsModule.initOccasionsManagement) {
    window.occasionsModule.initOccasionsManagement()
  }
})
